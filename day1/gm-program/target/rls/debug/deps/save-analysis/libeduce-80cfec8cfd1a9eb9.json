{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.1","compilation":{"directory":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19","program":"/home/nic/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rls","arguments":["--crate-name","educe","--edition=2021","/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","--json=diagnostic-rendered-ansi,artifacts,future-incompat","--crate-type","proc-macro","--emit=dep-info,link","-C","prefer-dynamic","-C","embed-bitcode=no","-C","debuginfo=2","--cfg","feature=\"Debug\"","--cfg","feature=\"Default\"","-C","metadata=80cfec8cfd1a9eb9","-C","extra-filename=-80cfec8cfd1a9eb9","--out-dir","/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps","-L","dependency=/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps","--extern","enum_ordinalize=/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps/libenum_ordinalize-807bb33b8372e056.so","--extern","proc_macro2=/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps/libproc_macro2-c7eb1a114f2b4dde.rlib","--extern","quote=/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps/libquote-4883eb1b74001552.rlib","--extern","syn=/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps/libsyn-6a97e48d8fa56e6e.rlib","--extern","proc_macro","--cap-lints","allow","--error-format=json","--sysroot","/home/nic/.rustup/toolchains/stable-x86_64-unknown-linux-gnu"],"output":"/home/nic/Documents/solana/solana-blockchain-developer-bootcamp/day1/gm-program/target/rls/debug/deps/libeduce-80cfec8cfd1a9eb9.so"},"prelude":{"crate_id":{"name":"educe","disambiguator":[5887241661871729741,0]},"crate_root":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src","external_crates":[{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[266559774140218402,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/support_traits.rs","num":2,"id":{"name":"core","disambiguator":[11763967750977672065,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[10106063140927293834,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[7335734036341381276,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[6464017807659102018,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[308958561119313021,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[16887813381474488870,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[18138047136180876386,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":9,"id":{"name":"miniz_oxide","disambiguator":[16720472299414307338,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[5531791840279234689,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":11,"id":{"name":"adler","disambiguator":[2995214285932701362,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":12,"id":{"name":"hashbrown","disambiguator":[17222063258158154566,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":13,"id":{"name":"std_detect","disambiguator":[7245893233601562531,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":14,"id":{"name":"rustc_demangle","disambiguator":[4839492760463372304,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":15,"id":{"name":"addr2line","disambiguator":[1226649225884195013,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":16,"id":{"name":"gimli","disambiguator":[12460504831400488231,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":17,"id":{"name":"object","disambiguator":[2536915343129323536,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":18,"id":{"name":"memchr","disambiguator":[4342342869490546433,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":19,"id":{"name":"panic_unwind","disambiguator":[2139538778087984071,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":20,"id":{"name":"enum_ordinalize","disambiguator":[8857897833646828615,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","num":21,"id":{"name":"quote","disambiguator":[3035844996877654492,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","num":22,"id":{"name":"proc_macro","disambiguator":[17355562761581328522,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_enum.rs","num":23,"id":{"name":"proc_macro2","disambiguator":[18144446792853996552,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","num":24,"id":{"name":"unicode_ident","disambiguator":[13320254083904757865,0]}},{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","num":25,"id":{"name":"syn","disambiguator":[8964952816721064474,0]}}],"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","byte_start":0,"byte_end":33733,"line_start":1,"line_end":1691,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","byte_start":0,"byte_end":33733,"line_start":1,"line_end":1691,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":42},{"krate":0,"index":46},{"krate":0,"index":678},{"krate":0,"index":681},{"krate":0,"index":684},{"krate":0,"index":687},{"krate":0,"index":688},{"krate":0,"index":691},{"krate":0,"index":694},{"krate":0,"index":697},{"krate":0,"index":700},{"krate":0,"index":703},{"krate":0,"index":704},{"krate":0,"index":840}],"decl_id":null,"docs":"# Educe","sig":null,"attributes":[{"value":"*\n# Educe\n\nThis crate provides procedural macros to help you implement Rust-built-in traits quickly.\n\n## Features\n\nBy default, every trait this crate supports will be enabled. You can disable all of them by disabling the default features and enable only the traits that you want to use by adding them to `features` explictly.\n\nFor example,\n\n```toml\n[dependencies.educe]\nversion = \"*\"\nfeatures = [\"Debug\", \"Default\", \"Hash\", \"Clone\", \"Copy\"]\ndefault-features = false\n```\n\n## Debug\n\nUse `#[derive(Educe)]` and `#[educe(Debug)]` to implement the `Debug` trait for a struct, an enum, or a union. It supports to change the name of your types, variants and fields. You can also ignore some fields, or set a trait and/or a method to replace the `Debug` trait used by default. Also, you can even format a struct to a tuple, and vice versa.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Debug)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Debug)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Change the Name of a Type, a Variant or a Field\n\nThe `name` attribute can help you rename a type, a variant or a field.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Debug(name = \"Struct2\"))]\nstruct Struct {\n    #[educe(Debug(name = \"f\"))]\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Debug(name = true))]\nenum Enum {\n    #[educe(Debug(name = false))]\n    V1,\n    #[educe(Debug(name = \"V\"))]\n    V2 {\n        #[educe(Debug(name = \"f\"))]\n        f1: u8,\n    },\n    #[educe(Debug(name = false))]\n    V3(u8),\n}\n```\n\n#### Ignore Fields\n\nThe `ignore` attribute can ignore specific fields.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Debug)]\nstruct Struct {\n    #[educe(Debug(ignore))]\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Debug)]\nenum Enum {\n    V1,\n    V2 {\n        #[educe(Debug(ignore))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Debug(ignore))]\n        u8\n    ),\n}\n```\n\n#### Fake Structs and Tuples\n\nWith the `named_field` attribute, structs can be formatted as tuples and tuples can be formatted as structs.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Debug(named_field = false))]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Debug)]\nenum Enum {\n    V1,\n    #[educe(Debug(named_field = false))]\n    V2 {\n        f1: u8,\n    },\n    #[educe(Debug(named_field = true))]\n    V3(\n        u8,\n        #[educe(Debug(name = \"value\"))]\n        i32\n    ),\n}\n```\n\n#### Use Another Method or Trait to Do the Format Thing\n\nThe `trait` and `method` attributes can be used to replace the `Debug` trait for fields. If you only set the `trait` parameter, the `method` will be set to `fmt` automatically by default.\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::fmt::{self, Formatter};\n\nfn fmt(_s: &u8, f: &mut Formatter) -> fmt::Result {\n    f.write_str(\"Hi\")\n}\n\ntrait A {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        f.write_str(\"Hi\")\n    }\n}\n\nimpl A for i32 {};\nimpl A for u64 {};\n\n#[derive(Educe)]\n#[educe(Debug)]\nenum Enum<T: A> {\n    V1,\n    V2 {\n        #[educe(Debug(method = \"fmt\"))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Debug(trait = \"std::fmt::UpperHex\"))]\n        u8,\n        #[educe(Debug(trait = \"A\"))]\n        T\n    ),\n}\n```\n\n#### Generic Parameters Bound to the `Debug` Trait or Others\n\nThe `#[educe(Debug(bound))]` attribute can be used to add the `Debug` trait bound to all generic parameters for the `Debug` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Debug(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself.\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::fmt::{self, Formatter};\n\nfn fmt(_s: &u8, f: &mut Formatter) -> fmt::Result {\n    f.write_str(\"Hi\")\n}\n\ntrait A {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        f.write_str(\"Hi\")\n    }\n}\n\nimpl A for i32 {};\nimpl A for u64 {};\n\n#[derive(Educe)]\n#[educe(Debug(bound = \"T: std::fmt::Debug, K: A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(Debug(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n#### Union\n\nA union will be formatted to a `u8` slice, because we don't know it's field at runtime. The fields of a union cannot be ignored, renamed or formated with other methods or traits.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Debug)]\nstruct Union {\n    f1: u8,\n    f2: i32,\n}\n```\n\n## PartialEq\n\nUse `#[derive(Educe)]` and `#[educe(ParitalEq)]` to implement the `ParitalEq` trait for a struct or an enum. It supports to ignore some fields, or set a trait and/or a method to replace the `ParitalEq` trait used by default.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Ignore Fields\n\nThe `ignore` attribute can ignore specific fields.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq)]\nstruct Struct {\n    #[educe(PartialEq(ignore))]\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq)]\nenum Enum {\n    V1,\n    V2 {\n        #[educe(PartialEq(ignore))]\n        f1: u8,\n    },\n    V3(\n        #[educe(PartialEq(ignore))]\n        u8\n    ),\n}\n```\n\n#### Use Another Method or Trait to Do Comparing\n\nThe `trait` and `method` attributes can be used to replace the `PartialEq` trait for fields. If you only set the `trait` parameter, the `method` will be set to `eq` automatically by default.\n\n```rust\n#[macro_use] extern crate educe;\n\nfn eq(a: &u8, b: &u8) -> bool {\n    a + 1 == *b\n}\n\ntrait A {\n    fn eq(&self, b: &Self) -> bool;\n}\n\nimpl A for i32 {\n    fn eq(&self, b: &i32) -> bool {\n        self + 1 == *b\n    }\n}\n\nimpl A for u64 {\n    fn eq(&self, b: &u64) -> bool {\n        self + 1 == *b\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq)]\nenum Enum<T: A> {\n    V1,\n    V2 {\n        #[educe(PartialEq(method = \"eq\"))]\n        f1: u8,\n    },\n    V3(\n        #[educe(PartialEq(trait = \"A\"))]\n        T\n    ),\n}\n```\n\n#### Generic Parameters Bound to the `PartialEq` Trait or Others\n\nThe `#[educe(PartialEq(bound))]` attribute can be used to add the `PartialEq` trait bound to all generaic parameters for the `PartialEq` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself.\n\n```rust\n#[macro_use] extern crate educe;\n\ntrait A {\n    fn eq(&self, b: &Self) -> bool;\n}\n\nimpl A for i32 {\n    fn eq(&self, b: &i32) -> bool {\n        self + 1 == *b\n    }\n}\n\nimpl A for u64 {\n    fn eq(&self, b: &u64) -> bool {\n        self + 1 == *b\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq(bound = \"T: std::cmp::PartialEq, K: A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(PartialEq(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n## Eq\n\nUse `#[derive(Educe)]` and `#[educe(Eq)]` to implement the `Eq` trait for a struct, an enum or a union.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Generic Parameters Bound to the `Eq` Trait or Others\n\nThe `#[educe(Eq(bound))]` attribute can be used to add the `Eq` trait bound to all generaic parameters for the `Eq` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq(bound), Eq(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself. (NOTE: The `Eq` trait depends on the `PartialEq` (`PartialEq<Self>`) trait.)\n\n```rust\n#[macro_use] extern crate educe;\n\ntrait A {\n    fn eq(&self, b: &Self) -> bool;\n}\n\nimpl A for i32 {\n    fn eq(&self, b: &i32) -> bool {\n        self + 1 == *b\n    }\n}\n\nimpl A for u64 {\n    fn eq(&self, b: &u64) -> bool {\n        self + 1 == *b\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq(bound = \"T: std::cmp::PartialEq, K: A\"), Eq(bound = \"T: std::cmp::PartialEq, K: A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(PartialEq(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n## PartialOrd\n\nUse `#[derive(Educe)]` and `#[educe(PartialOrd)]` to implement the `PartialOrd` trait for a struct or an enum. It supports to ignore some fields, or set a trait and/or a method to replace the `PartialOrd` trait used by default. The rank of variants and fields can also be modified.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Ignore Fields\n\nThe `ignore` attribute can ignore specific fields.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nstruct Struct {\n    #[educe(PartialOrd(ignore))]\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nenum Enum {\n    V1,\n    V2 {\n        #[educe(PartialOrd(ignore))]\n        f1: u8,\n    },\n    V3(\n        #[educe(PartialOrd(ignore))]\n        u8\n    ),\n}\n```\n\n#### Use Another Method or Trait to Do Comparing\n\nThe `trait` and `method` attributes can be used to replace the `PartialOrd` trait for fields. If you only set the `trait` parameter, the `method` will be set to `partial_cmp` automatically by default.\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::cmp::Ordering;\n\nfn partial_cmp(a: &u8, b: &u8) -> Option<Ordering> {\n    if a > b {\n        Some(Ordering::Less)\n    } else if a < b {\n        Some(Ordering::Greater)\n    } else {\n        Some(Ordering::Equal)\n    }\n}\n\ntrait A {\n    fn partial_cmp(&self, b: &Self) -> Option<Ordering>;\n}\n\nimpl A for i32 {\n    fn partial_cmp(&self, b: &i32) -> Option<Ordering> {\n        if self > b {\n            Some(Ordering::Less)\n        } else if self < b {\n            Some(Ordering::Greater)\n        } else {\n            Some(Ordering::Equal)\n        }\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nenum Enum<T: std::cmp::PartialEq + A> {\n    V1,\n    V2 {\n        #[educe(PartialOrd(method = \"partial_cmp\"))]\n        f1: u8,\n    },\n    V3(\n        #[educe(PartialOrd(trait = \"A\"))]\n        T\n    ),\n}\n```\n\n#### Generic Parameters Bound to the `PartialOrd` Trait or Others\n\nThe `#[educe(PartialOrd(bound))]` attribute can be used to add the `PartialOrd` trait bound to all generaic parameters for the `PartialOrd` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq(bound), PartialOrd(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself. (NOTE: The `PartialOrd` trait depends on the `PartialEq` (`PartialEq<Self>`) trait.)\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::cmp::Ordering;\n\ntrait A {\n    fn partial_cmp(&self, b: &Self) -> Option<Ordering>;\n}\n\nimpl A for i32 {\n    fn partial_cmp(&self, b: &i32) -> Option<Ordering> {\n        if self > b {\n            Some(Ordering::Less)\n        } else if self < b {\n            Some(Ordering::Greater)\n        } else {\n            Some(Ordering::Equal)\n        }\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq(bound), PartialOrd(bound = \"T: std::cmp::PartialOrd, K: std::cmp::PartialOrd + A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(PartialOrd(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n#### Ranking\n\nEach field can add a `#[educe(PartialOrd(rank = priority_value))]` attribute where `priority_value` is a positive integer value to determine their comparing precedence (lower `priority_value` leads to higher priority). The default `priority_value` for a field dependends on its ordinal (the lower the front) and is always lower than any custom `priority_value`.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nstruct Struct {\n    #[educe(PartialOrd(rank = 1))]\n    f1: u8,\n    #[educe(PartialOrd(rank = 0))]\n    f2: u8,\n}\n```\n\nEach variant can add a `#[educe(PartialOrd(rank = comparison_value))]` attribute where `comparison_value` is a positive integer value to override the value or the ordinal of a variant for comparison.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, PartialOrd)]\nenum Enum {\n    #[educe(PartialOrd(rank = 2))]\n    Two,\n    #[educe(PartialOrd(rank = 1))]\n    One,\n}\n```\n\n## Ord\n\nUse `#[derive(Educe)]` and `#[educe(Ord)]` to implement the `Ord` trait for a struct or an enum. It supports to ignore some fields, or set a trait and/or a method to replace the `Ord` trait used by default. The rank of variants and fields can also be modified.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Ignore Fields\n\nThe `ignore` attribute can ignore specific fields.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nstruct Struct {\n    #[educe(Ord(ignore))]\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nenum Enum {\n    V1,\n    V2 {\n        #[educe(Ord(ignore))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Ord(ignore))]\n        u8\n    ),\n}\n```\n\n#### Use Another Method or Trait to Do Comparing\n\nThe `trait` and `method` attributes can be used to replace the `Ord` trait for fields. If you only set the `trait` parameter, the `method` will be set to `cmp` automatically by default.\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::cmp::Ordering;\n\nfn cmp(a: &u8, b: &u8) -> Ordering {\n    if a > b {\n        Ordering::Less\n    } else if a < b {\n        Ordering::Greater\n    } else {\n        Ordering::Equal\n    }\n}\n\ntrait A {\n    fn cmp(&self, b: &Self) -> Ordering;\n}\n\nimpl A for i32 {\n    fn cmp(&self, b: &i32) -> Ordering {\n        if self > b {\n            Ordering::Less\n        } else if self < b {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n        }\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nenum Enum<T: std::cmp::PartialOrd + A> {\n    V1,\n    V2 {\n        #[educe(Ord(method = \"cmp\"))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Ord(trait = \"A\"))]\n        T\n    ),\n}\n```\n\n#### Generic Parameters Bound to the `Ord` Trait or Others\n\nThe `#[educe(Ord(bound))]` attribute can be used to add the `Ord` trait bound to all generaic parameters for the `Ord` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq(bound), Eq(bound), PartialOrd(bound), Ord(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself. (NOTE: The `Ord` trait depends on the `PartialOrd` (`PartialOrd<Self>`) trait and the `Eq` trait.)\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::cmp::Ordering;\n\ntrait A {\n    fn cmp(&self, b: &Self) -> Ordering;\n}\n\nimpl A for i32 {\n    fn cmp(&self, b: &i32) -> Ordering {\n        if self > b {\n            Ordering::Less\n        } else if self < b {\n            Ordering::Greater\n        } else {\n            Ordering::Equal\n        }\n    }\n}\n\n#[derive(Educe)]\n#[educe(PartialEq(bound), Eq(bound), PartialOrd(bound), Ord(bound = \"T: std::cmp::Ord, K: std::cmp::Ord + A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(Ord(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n#### Ranking\n\nEach field can add a `#[educe(Ord(rank = priority_value))]` attribute where `priority_value` is a positive integer value to determine their comparing precedence (lower `priority_value` leads to higher priority). The default `priority_value` for a field dependends on its ordinal (the lower the front) and is always lower than any custom `priority_value`.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nstruct Struct {\n    #[educe(Ord(rank = 1))]\n    f1: u8,\n    #[educe(Ord(rank = 0))]\n    f2: u8,\n}\n```\n\nEach variant can add a `#[educe(Ord(rank = comparison_value))]` attribute where `comparison_value` is a positive integer value to override the value or the ordinal of a variant for comparison.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(PartialEq, Eq, PartialOrd, Ord)]\nenum Enum {\n    #[educe(Ord(rank = 2))]\n    Two,\n    #[educe(Ord(rank = 1))]\n    One,\n}\n```\n\n## Hash\n\nUse `#[derive(Educe)]` and `#[educe(Hash)]` to implement the `Hash` trait for a struct or an enum. It supports to ignore some fields, or set a trait and/or a method to replace the `Hash` trait used by default.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Hash)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Hash)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Ignore Fields\n\nThe `ignore` attribute can ignore specific fields.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Hash)]\nstruct Struct {\n    #[educe(Hash(ignore))]\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Hash)]\nenum Enum {\n    V1,\n    V2 {\n        #[educe(Hash(ignore))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Hash(ignore))]\n        u8\n    ),\n}\n```\n\n#### Use Another Method or Trait to Do Hashing\n\nThe `trait` and `method` attributes can be used to replace the `Hash` trait for fields. If you only set the `trait` parameter, the `method` will be set to `hash` automatically by default.\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::hash::{Hash, Hasher};\n\nfn hash<H: Hasher>(_s: &u8, state: &mut H) {\n    Hash::hash(&100, state)\n}\n\ntrait A {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        Hash::hash(&100, state)\n    }\n}\n\nimpl A for i32 {};\nimpl A for u64 {};\n\n#[derive(Educe)]\n#[educe(Hash)]\nenum Enum<T: A> {\n    V1,\n    V2 {\n        #[educe(Hash(method = \"hash\"))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Hash(trait = \"A\"))]\n        T\n    ),\n}\n```\n\n#### Generic Parameters Bound to the `Hash` Trait or Others\n\nThe `#[educe(Hash(bound))]` attribute can be used to add the `Hash` trait bound to all generaic parameters for the `Hash` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Hash(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself.\n\n```rust\n#[macro_use] extern crate educe;\n\nuse std::hash::{Hash, Hasher};\n\nfn hash<H: Hasher>(_s: &u8, state: &mut H) {\n    Hash::hash(&100, state)\n}\n\ntrait A {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        Hash::hash(&100, state)\n    }\n}\n\nimpl A for i32 {};\nimpl A for u64 {};\n\n#[derive(Educe)]\n#[educe(Hash(bound = \"T: std::hash::Hash, K: A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(Hash(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n## Default\n\nUse `#[derive(Educe)]` and `#[educe(Default)]` to implement the `Default` trait for a struct, an enum, or a union. It supports to set the default value for your type directly, or set the default values for specific fields.\n\n#### Basic Usage\n\nFor enums and unions, you need to assign a variant (of a enum) and a field (of a union) as default unless the number of variants of an enum or the number of fields of a union is exactly one.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Default)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Default)]\nenum Enum {\n    V1,\n    #[educe(Default)]\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n\n#[derive(Educe)]\n#[educe(Default)]\nunion Union {\n    f1: u8,\n    #[educe(Default)]\n    f2: f64,\n}\n```\n\n#### The Default Value for the Whole Type\n\nThe `#[educe(Default(expression = \"expression\"))]` attribute can be used to set the default value for your type by an expression.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Default(expression = \"Struct { f1: 1 }\"))]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Default(expression = \"Enum::Struct { f1: 1 }\"))]\nenum Enum {\n    Unit,\n    Struct {\n        f1: u8\n    },\n    Tuple(u8),\n}\n\n#[derive(Educe)]\n#[educe(Default(expression = \"Union { f1: 1 }\"))]\nunion Union {\n    f1: u8,\n    f2: f64,\n}\n```\n\n#### The Default Values for Specific Fields\n\nThe `#[educe(Default = literal)]` attribute or the `#[educe(Default(expression = \"expression\"))]` attribute can be used to set the default value for a specific field by a literal value or an expression.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Default)]\nstruct Struct {\n    #[educe(Default = 1)]\n    f1: u8,\n    #[educe(Default = 11111111111111111111111111111)]\n    f2: i128,\n    #[educe(Default = 1.1)]\n    f3: f64,\n    #[educe(Default = true)]\n    f4: bool,\n    #[educe(Default = \"Hi\")]\n    f5: &'static str,\n    #[educe(Default = \"Hello\")]\n    f6: String,\n    #[educe(Default = 'M')]\n    f7: char,\n}\n\n#[derive(Educe)]\n#[educe(Default)]\nenum Enum {\n    Unit,\n    #[educe(Default)]\n    Tuple(\n        #[educe(Default(expression = \"0 + 1\"))]\n        u8,\n        #[educe(Default(expression = \"-11111111111111111111111111111 * -1\"))]\n        i128,\n        #[educe(Default(expression = \"1.0 + 0.1\"))]\n        f64,\n        #[educe(Default(expression = \"!false\"))]\n        bool,\n        #[educe(Default(expression = \"\\\"Hi\\\"\"))]\n        &'static str,\n        #[educe(Default(expression = \"String::from(\\\"Hello\\\")\"))]\n        String,\n        #[educe(Default(expression = \"'M'\"))]\n        char,\n    ),\n}\n\n#[derive(Educe)]\n#[educe(Default)]\nunion Union {\n    f1: u8,\n    f2: i128,\n    f3: f64,\n    f4: bool,\n    #[educe(Default = \"Hi\")]\n    f5: &'static str,\n    f6: char,\n}\n```\n\n#### Generic Parameters Bound to the `Default` Trait or Others\n\nThe `#[educe(Default(bound))]` attribute can be used to add the `Default` trait bound to all generaic parameters for the `Default` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Default(bound))]\nenum Enum<T> {\n    Unit,\n    #[educe(Default)]\n    Struct {\n        f1: T\n    },\n    Tuple(T),\n}\n```\n\nOr you can set the where predicates by yourself.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Default(bound = \"T: std::default::Default\"))]\nenum Enum<T> {\n    Unit,\n    #[educe(Default)]\n    Struct {\n        f1: T\n    },\n    Tuple(T),\n}\n```\n\n#### The `new` Associated Function\n\nWith the `#[educe(Default(new))]` attribute, your type will have an extra associated function called `new`. That can be used to invoke the `default` method of the `Default` trait.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Default(new))]\nstruct Struct {\n    f1: u8\n}\n```\n\n## Clone\n\nUse `#[derive(Educe)]` and `#[educe(Clone)]` to implement the `Clone` trait for a struct, an enum, or a union. It supports to set a trait and/or a method to replace the `Clone` trait used by default.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Clone)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Clone)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Use Another Method or Trait to Do Cloning\n\nThe `trait` and `method` attributes can be used to replace the `Clone` trait for fields. If you only set the `trait` parameter, the `method` will be set to `clone` automatically by default.\n\n```rust\n#[macro_use] extern crate educe;\n\nfn clone(v: &u8) -> u8 {\n    v + 100\n}\n\ntrait A {\n    fn clone(&self) -> Self;\n}\n\nimpl A for i32 {\n    fn clone(&self) -> i32 {\n        self + 100\n    }\n}\n\nimpl A for u64 {\n    fn clone(&self) -> u64 {\n        self + 100\n    }\n}\n\n#[derive(Educe)]\n#[educe(Clone)]\nenum Enum<T: A> {\n    V1,\n    V2 {\n        #[educe(Clone(method = \"clone\"))]\n        f1: u8,\n    },\n    V3(\n        #[educe(Clone(trait = \"A\"))]\n        T\n    ),\n}\n```\n\n#### Generic Parameters Bound to the `Clone` Trait or Others\n\nThe `#[educe(Clone(bound))]` attribute can be used to add the `Clone` trait bound or the `Copy` trait bound (if the `#[educe(Copy)]` attribute exists) to all generaic parameters for the `Clone` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Clone(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself.\n\n```rust\n#[macro_use] extern crate educe;\n\nfn clone(v: &u8) -> u8 {\n    v + 100\n}\n\ntrait A {\n    fn clone(&self) -> Self;\n}\n\nimpl A for i32 {\n    fn clone(&self) -> i32 {\n        self + 100\n    }\n}\n\nimpl A for u64 {\n    fn clone(&self) -> u64 {\n        self + 100\n    }\n}\n\n#[derive(Educe)]\n#[educe(Clone(bound = \"T: std::clone::Clone, K: A\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(Clone(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n#### Union\n\nThe `#[educe(Clone)]` attribute can be used for a union which also needs to implement the `Copy` trait. The fields of a union cannot be cloned with other methods or traits.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Copy, Clone)]\nunion Union {\n    f1: u8,\n}\n```\n\n## Copy\n\nUse `#[derive(Educe)]` and `#[educe(Copy)]` to implement the `Copy` trait for a struct, an enum, or a union.\n\n#### Basic Usage\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Copy, Clone)]\nstruct Struct {\n    f1: u8\n}\n\n#[derive(Educe)]\n#[educe(Copy, Clone)]\nenum Enum {\n    V1,\n    V2 {\n        f1: u8,\n    },\n    V3(u8),\n}\n```\n\n#### Generic Parameters Bound to the `Copy` Trait or Others\n\nThe `#[educe(Copy(bound))]` attribute can be used to add the `Copy` trait bound to all generaic parameters for the `Copy` implementation.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Copy(bound), Clone(bound))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\nOr you can set the where predicates by yourself.\n\n```rust\n#[macro_use] extern crate educe;\n\nfn clone(v: &u8) -> u8 {\n    v + 100\n}\n\ntrait A {\n    fn clone(&self) -> Self;\n}\n\nimpl A for i32 {\n    fn clone(&self) -> i32 {\n        self + 100\n    }\n}\n\nimpl A for u64 {\n    fn clone(&self) -> u64 {\n        self + 100\n    }\n}\n\n#[derive(Educe)]\n#[educe(Copy(bound = \"T: Copy, K: A + Copy\"), Clone(bound = \"T: Copy, K: A + Copy\"))]\nenum Enum<T, K> {\n    V1,\n    V2 {\n        #[educe(Clone(trait = \"A\"))]\n        f1: K,\n    },\n    V3(\n        T\n    ),\n}\n```\n\n#### Copy and Clone\n\nIf you implement both of the `Copy` trait and the `Clone` trait by Educe, the bound for the `Clone` trait needs to include the `Copy` trait due to `Copy, Clone` optimization.\n\n## Deref\n\nUse `#[derive(Educe)]` and `#[educe(Deref)]` to implement the `Deref` trait for a struct or an enum.\n\n#### Basic Usage\n\nYou need to assign a field as a default inmutable dereferencing field unless the number of fields is exactly one.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Deref)]\nstruct Struct {\n    f1: u8,\n    #[educe(Deref)]\n    f2: u8,\n}\n\n#[derive(Educe)]\n#[educe(Deref)]\nenum Enum {\n    Struct {\n        f1: u8\n    },\n    Struct2 {\n        f1: u8,\n        #[educe(Deref)]\n        f2: u8,\n    },\n    Tuple(u8),\n    Tuple2(\n        u8,\n        #[educe(Deref)]\n        u8\n    ),\n}\n```\n\n## DerefMut\n\nUse `#[derive(Educe)]` and `#[educe(DerefMut)]` to implement the `DerefMut` trait for a struct or an enum.\n\n#### Basic Usage\n\nYou need to assign a field as a default mutable dereferencing field unless the number of fields is exactly one.\n\n```rust\n#[macro_use] extern crate educe;\n\n#[derive(Educe)]\n#[educe(Deref, DerefMut)]\nstruct Struct {\n    f1: u8,\n    #[educe(Deref, DerefMut)]\n    f2: u8,\n}\n\n#[derive(Educe)]\n#[educe(Deref, DerefMut)]\nenum Enum {\n    Struct {\n        f1: u8\n    },\n    Struct2 {\n        f1: u8,\n        #[educe(Deref, DerefMut)]\n        f2: u8,\n    },\n    Tuple(u8),\n    Tuple2(\n        #[educe(DerefMut)]\n        u8,\n        #[educe(Deref)]\n        u8\n    ),\n}\n```\n\nThe mutable dereferencing fields don't need to be the same as the inmutable dereferencing fields. But their type must be the same.\n\n## TODO\n\nThere is a lot of work to be done. Unimplemented traits are listed below:\n\n1. `From`\n1. `Into`\n1. `FromStr`\n1. `TryFrom`\n1. `TryInto`\n\n*/","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","byte_start":0,"byte_end":28613,"line_start":1,"line_end":1509,"column_start":1,"column_end":3}},{"value":"recursion_limit = \"128\"","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","byte_start":28615,"byte_end":28642,"line_start":1511,"line_end":1511,"column_start":1,"column_end":28}}]},{"kind":"Function","id":{"krate":0,"index":704},"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","byte_start":33598,"byte_end":33610,"line_start":1689,"line_end":1689,"column_start":8,"column_end":20},"name":"educe_derive","qualname":"::educe_derive","value":"pub fn educe_derive(proc_macro::TokenStream) -> proc_macro::TokenStream","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"proc_macro_derive(Educe, attributes(educe))","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/lib.rs","byte_start":33544,"byte_end":33590,"line_start":1688,"line_end":1688,"column_start":1,"column_end":47}}]}],"impls":[{"id":1,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/support_traits.rs","byte_start":40346,"byte_end":40351,"line_start":43,"line_end":43,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":44}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","byte_start":45473,"byte_end":45491,"line_start":15,"line_end":15,"column_start":6,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":76}],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","byte_start":46065,"byte_end":46086,"line_start":40,"line_end":40,"column_start":6,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":78},{"krate":0,"index":79}],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/type_attribute.rs","byte_start":71338,"byte_end":71355,"line_start":22,"line_end":22,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":133}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/type_attribute.rs","byte_start":71750,"byte_end":71768,"line_start":39,"line_end":39,"column_start":6,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":135}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/type_attribute.rs","byte_start":72764,"byte_end":72784,"line_start":75,"line_end":75,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":137},{"krate":0,"index":138}],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_enum.rs","byte_start":96858,"byte_end":96874,"line_start":18,"line_end":18,"column_start":23,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":199}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_struct.rs","byte_start":129091,"byte_end":129109,"line_start":17,"line_end":17,"column_start":23,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":257}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_union.rs","byte_start":141967,"byte_end":141984,"line_start":14,"line_end":14,"column_start":23,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":300}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/mod.rs","byte_start":44531,"byte_end":44543,"line_start":20,"line_end":20,"column_start":23,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":332}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/models/field_attribute.rs","byte_start":146078,"byte_end":146099,"line_start":23,"line_end":23,"column_start":6,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":362},{"krate":0,"index":363}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/models/type_attribute.rs","byte_start":155408,"byte_end":155426,"line_start":22,"line_end":22,"column_start":6,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":417}],"docs":"","sig":null,"attributes":[]},{"id":13,"kind":"Inherent","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/models/type_attribute.rs","byte_start":156359,"byte_end":156379,"line_start":56,"line_end":56,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":419},{"krate":0,"index":420}],"docs":"","sig":null,"attributes":[]},{"id":14,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/default_enum.rs","byte_start":172260,"byte_end":172278,"line_start":16,"line_end":16,"column_start":23,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":478}],"docs":"","sig":null,"attributes":[]},{"id":15,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/default_struct.rs","byte_start":186151,"byte_end":186171,"line_start":15,"line_end":15,"column_start":23,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":532}],"docs":"","sig":null,"attributes":[]},{"id":16,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/default_union.rs","byte_start":195498,"byte_end":195517,"line_start":16,"line_end":16,"column_start":23,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":585}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Direct","span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/mod.rs","byte_start":144932,"byte_end":144946,"line_start":20,"line_end":20,"column_start":23,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":617}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/support_traits.rs","byte_start":40346,"byte_end":40351,"line_start":43,"line_end":43,"column_start":6,"column_end":11},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":705},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","byte_start":45473,"byte_end":45491,"line_start":15,"line_end":15,"column_start":6,"column_end":24},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":732},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/field_attribute.rs","byte_start":46065,"byte_end":46086,"line_start":40,"line_end":40,"column_start":6,"column_end":27},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":751},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/type_attribute.rs","byte_start":71338,"byte_end":71355,"line_start":22,"line_end":22,"column_start":6,"column_end":23},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":760},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/type_attribute.rs","byte_start":71750,"byte_end":71768,"line_start":39,"line_end":39,"column_start":6,"column_end":24},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":772},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/models/type_attribute.rs","byte_start":72764,"byte_end":72784,"line_start":75,"line_end":75,"column_start":6,"column_end":26},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":789},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_enum.rs","byte_start":96858,"byte_end":96874,"line_start":18,"line_end":18,"column_start":23,"column_end":39},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":196},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_struct.rs","byte_start":129091,"byte_end":129109,"line_start":17,"line_end":17,"column_start":23,"column_end":41},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":254},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/debug_union.rs","byte_start":141967,"byte_end":141984,"line_start":14,"line_end":14,"column_start":23,"column_end":40},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":297},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/debug/mod.rs","byte_start":44531,"byte_end":44543,"line_start":20,"line_end":20,"column_start":23,"column_end":35},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":329},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/models/field_attribute.rs","byte_start":146078,"byte_end":146099,"line_start":23,"line_end":23,"column_start":6,"column_end":27},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":806},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/models/type_attribute.rs","byte_start":155408,"byte_end":155426,"line_start":22,"line_end":22,"column_start":6,"column_end":24},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":814},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/models/type_attribute.rs","byte_start":156359,"byte_end":156379,"line_start":56,"line_end":56,"column_start":6,"column_end":26},"kind":{"Impl":{"id":13}},"from":{"krate":0,"index":831},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/default_enum.rs","byte_start":172260,"byte_end":172278,"line_start":16,"line_end":16,"column_start":23,"column_end":41},"kind":{"Impl":{"id":14}},"from":{"krate":0,"index":475},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/default_struct.rs","byte_start":186151,"byte_end":186171,"line_start":15,"line_end":15,"column_start":23,"column_end":43},"kind":{"Impl":{"id":15}},"from":{"krate":0,"index":529},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/default_union.rs","byte_start":195498,"byte_end":195517,"line_start":16,"line_end":16,"column_start":23,"column_end":42},"kind":{"Impl":{"id":16}},"from":{"krate":0,"index":582},"to":{"krate":0,"index":668}},{"span":{"file_name":"/home/nic/.cargo/registry/src/github.com-1ecc6299db9ec823/educe-0.4.19/src/trait_handlers/default/mod.rs","byte_start":144932,"byte_end":144946,"line_start":20,"line_end":20,"column_start":23,"column_end":37},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":614},"to":{"krate":0,"index":668}}]}